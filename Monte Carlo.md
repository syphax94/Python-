# La simulation Monte Carlo

 Les simulations de Monte-Carlo sont des algorithmes utilisés dans le but d’estimer la probabilité d’occurrence d’un scénario dans lequel interviennent des paramètres aléatoires. 
 
 C’est une technique statistique permettant de comprendre l’influence de l’incertitude dans les modèles de prédiction, notamment en finance.


# Nous allons prendre l'action AIR LIQUIDE, prix  initial 158.20€

* Volatilité 1.11%
 
![alt text](https://i.ibb.co/FYXdLJV/screen2.png)

Drift = Excepted Return = Risk free rate + (Beta*Market Return Premium)
                        -> Excepted Return = 0.243% + ( 0.57 * 1.76%)
                        -> Drift = 0.244%
* Beta

![alt text](https://i.ibb.co/Hgm0wdc/beta.png)

# Code Simulation Monte Carlo

```python
import matplotlib.pyplot as plt
import numpy as np
import math


class European_Call_Payoff:

    def __init__(self, strike):
        self.strike = strike

    def get_payoff(self, stock_price):
        if stock_price > self.strike:
            return stock_price - self.strike
        else:
            return 0


class GeometricBrownianMotion:

    def simulate_paths(self):
        while(self.T - self.dt > 0):
            dWt = np.random.normal(0, math.sqrt(self.dt))  # Brownian motion
            dYt = self.drift*self.dt + self.volatility*dWt  # Change in price
            self.current_price += dYt  # Add the change to the current price
            self.prices.append(self.current_price)  # Append new price to series
            self.T -= self.dt  # Accound for the step in time

    def __init__(self, initial_price, drift, volatility, dt, T):
        self.current_price = initial_price
        self.initial_price = initial_price
        self.drift = drift
        self.volatility = volatility
        self.dt = dt
        self.T = T
        self.prices = []
        self.simulate_paths()

# Model Parameters
paths = 100
initial_price = 158.20
drift = .0244
volatility = .0111
dt = 1/365
T = 1
price_paths = []

# Generate a set of sample paths
for i in range(0, paths):
    price_paths.append(GeometricBrownianMotion(initial_price, drift, volatility, dt, T).prices)

call_payoffs = []
ec = European_Call_Payoff(100)
risk_free_rate = .01
for price_path in price_paths:
    call_payoffs.append(ec.get_payoff(price_path[-1])/(1 + risk_free_rate))  # We get the last stock price in the series generated by GBM to determin the payoff and discount it by one year

# Plot the set of generated sample paths
for price_path in price_paths:
    plt.plot(price_path)
plt.show()

print(np.average(call_payoffs)*100)  # Options are in blocks of 100

```

![alt text](https://i.ibb.co/hZ86Xzg/screen1.png)
